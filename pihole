#!/usr/bin/env bash

# Pi-hole: A black hole for Internet advertisements
# (c) 2017 Pi-hole, LLC (https://pi-hole.net)
# Network-wide ad blocking via your own hardware.
#
# Controller for all pihole scripts and functions.
#
# This file is copyright under the latest version of the EUPL.
# Please see LICENSE file for your rights under this license.

PI_HOLE_SCRIPT_DIR="/opt/pihole"

# PI_HOLE_BIN_DIR is not readonly here because in some functions (checkout),
# they might get set again when the installer is sourced. This causes an
# error due to modifying a readonly variable.
PI_HOLE_BIN_DIR="/usr/local/bin"

readonly colfile="${PI_HOLE_SCRIPT_DIR}/COL_TABLE"
# shellcheck source=./advanced/Scripts/COL_TABLE
source "${colfile}"

utilsfile="${PI_HOLE_SCRIPT_DIR}/utils.sh"
# shellcheck source=./advanced/Scripts/utils.sh
source "${utilsfile}"

# Source api functions
readonly apifile="${PI_HOLE_SCRIPT_DIR}/api.sh"
# shellcheck source=./advanced/Scripts/api.sh
source "${apifile}"

versionsfile="/etc/pihole/versions"
if [ -f "${versionsfile}" ]; then
    # Only source versionsfile if the file exits
    # fixes a warning during installation where versionsfile does not exist yet
    # but gravity calls `pihole -status` and thereby sourcing the file
    # shellcheck source=/dev/null
    source "${versionsfile}"
fi

# TODO: We can probably remove the reliance on this function too, just tell people to pihole-FTL --config webserver.api.password "password"
SetWebPassword() {
    if [ -n "$2" ] ; then
        readonly PASSWORD="$2"
        readonly CONFIRM="${PASSWORD}"
    else
        # Prevents a bug if the user presses Ctrl+C and it continues to hide the text typed.
        # So we reset the terminal via stty if the user does press Ctrl+C
        trap '{ echo -e "\n未更改" ; stty sane ; exit 1; }' INT
        read -s -r -p "请输入新密码（留空则无密码）：" PASSWORD
        echo ""

        if [ "${PASSWORD}" == "" ]; then
            setFTLConfigValue "webserver.api.password" ""
            echo -e "  ${TICK} 密码已移除"
            exit 0
        fi

        read -s -r -p "确认密码：" CONFIRM
        echo ""
    fi

    if [ "${PASSWORD}" == "${CONFIRM}" ] ; then
        # pihole-FTL will automatically hash the password
        setFTLConfigValue "webserver.api.password" "${PASSWORD}"
        echo -e "  ${TICK} 新密码已设置"
    else
        echo -e "  ${CROSS} 密码不匹配。您的密码未更改"
        exit 1
    fi
}

listFunc() {
  "${PI_HOLE_SCRIPT_DIR}"/list.sh "$@"
  exit 0
}

debugFunc() {
    local automated
    local check_database_integrity
    # Pull off the `debug` leaving passed call augmentation flags in $1
    shift

    for value in "$@"; do
        [[ "$value"  == *"-a"* ]] && automated="true"
        [[ "$value"  == *"-c"* ]] && check_database_integrity="true"
        [[ "$value" == *"--check_database"* ]] && check_database_integrity="true"
    done

  AUTOMATED=${automated:-} CHECK_DATABASE=${check_database_integrity:-} "${PI_HOLE_SCRIPT_DIR}"/piholeDebug.sh
  exit 0
}

flushFunc() {
  "${PI_HOLE_SCRIPT_DIR}"/piholeLogFlush.sh "$@"
  exit 0
}

# Deprecated function, should be removed in the future
# use networkFlush instead
arpFunc() {
  shift
  echo -e "  ${INFO} 'arpflush' 命令已弃用，请改用 'networkflush'"
  "${PI_HOLE_SCRIPT_DIR}"/piholeNetworkFlush.sh "$@"
  exit 0
}

networkFlush() {
  shift
  "${PI_HOLE_SCRIPT_DIR}"/piholeNetworkFlush.sh "$@"
  exit 0
}

updatePiholeFunc() {
  if [ -n "${DOCKER_VERSION}" ]; then
    unsupportedFunc
  else
    shift
    "${PI_HOLE_SCRIPT_DIR}"/update.sh "$@"
    exit 0
  fi
}

repairPiholeFunc() {
  if [ -n "${DOCKER_VERSION}" ]; then
    unsupportedFunc
  else
    /etc/.pihole/automated\ install/basic-install.sh --repair
    exit 0;
  fi
}

updateGravityFunc() {
  exec "${PI_HOLE_SCRIPT_DIR}"/gravity.sh "$@"
}

queryFunc() {
  shift
  "${PI_HOLE_SCRIPT_DIR}"/query.sh "$@"
  exit 0
}

chronometerFunc() {
  echo "Chronometer 已移除，请使用 PADD (https://github.com/pi-hole/PADD)"
  exit 0
}


uninstallFunc() {
  if [ -n "${DOCKER_VERSION}" ]; then
    unsupportedFunc
  else
    "${PI_HOLE_SCRIPT_DIR}"/uninstall.sh
    exit 0
  fi
}

versionFunc() {
  exec "${PI_HOLE_SCRIPT_DIR}"/version.sh
  exit 0
}

reloadDNS() {
  local svcOption svc str output status pid icon FTL_PID_FILE sigrtmin
  svcOption="${1:-reload}"

  # get the current path to the pihole-FTL.pid
  FTL_PID_FILE="$(getFTLConfigValue files.pid)"

  # Determine if we should reload or restart
  if [[ "${svcOption}" =~ "reload-lists" ]]; then
    # Reloading of the lists has been requested
    # Note 1: This will NOT re-read any *.conf files
    # Note 2: We cannot use killall here as it does
    #         not know about real-time signals

    pid="$(getFTLPID ${FTL_PID_FILE})"
    if [[ "$pid" -eq "-1" ]]; then
      svc="true"
      str="FTL 未运行"
      icon="${INFO}"
    else
      sigrtmin="$(pihole-FTL sigrtmin 2>/dev/null)"
      # Make sure sigrtmin is a number, otherwise fallback to RTMIN
      [[ "${sigrtmin}" =~ ^[0-9]+$ ]] || unset sigrtmin
      svc="kill -${sigrtmin:-RTMIN} ${pid}"
      str="重新加载 DNS 列表"
      icon="${TICK}"
    fi
  elif [[ "${svcOption}" =~ "reload" ]]; then
    # Reloading of the DNS cache has been requested
    # Note: This will NOT re-read any *.conf files
    pid="$(getFTLPID ${FTL_PID_FILE})"
    if [[ "$pid" -eq "-1" ]]; then
      svc="true"
      str="FTL 未运行"
      icon="${INFO}"
    else
      svc="kill -HUP ${pid}"
      str="刷新 DNS 缓存"
      icon="${TICK}"
    fi
  fi

  # Print output to Terminal, but not to Web Admin
  [[ -t 1 ]] && echo -ne "  ${INFO} ${str}..."

  output=$( { ${svc}; } 2>&1 )
  status="$?"

  if [[ "${status}" -eq 0 ]]; then
    [[ -t 1 ]] && echo -e "${OVER}  ${icon} ${str}"
    return 0
  else
    [[ ! -t 1 ]] && local OVER=""
    echo -e "${OVER}  ${CROSS} ${output}"
    return 1
  fi
}

piholeEnable() {
  if [[ "${2}" == "-h" ]] || [[ "${2}" == "--help" ]]; then
    echo "用法：pihole enable/disable [time]
示例：'pihole enable'，或 'pihole disable 5m'
启用或禁用 Pi-hole 子系统

时间：
  #s               启用/禁用 Pi-hole 功能 # 秒
  #m               启用/禁用 Pi-hole 功能 # 分钟"
    exit 0

  fi

  # Get timer
  local tt="null"
  if [[ $# -gt 1 ]]; then
    local error=false
    if [[ "${2}" == *"s" ]]; then
      tt=${2%"s"}
      if [[ ! "${tt}" =~ ^-?[0-9]+$ ]];then
        local error=true
      fi
    elif [[ "${2}" == *"m" ]]; then
      tt=${2%"m"}
      if [[ "${tt}" =~ ^-?[0-9]+$ ]];then
        tt=$((${tt}*60))
      else
        local error=true
      fi
    elif [[ -n "${2}" ]]; then
      local error=true
    fi

    if [[ ${error} == true ]];then
      echo -e "  ${COL_RED}未知的屏蔽定时器格式！${COL_NC}"
      echo -e "  尝试 'pihole disable --help' 获取更多信息。"
      exit 1
    fi
  fi

  # Authenticate with the API
  LoginAPI

  # Send the request
  data=$(PostFTLData "dns/blocking" "{ \"blocking\": ${1}, \"timer\": ${tt} }")

  # Check the response
  local extra timer
  extra=" 永久"
  timer="$(echo "${data}"| jq --raw-output '.timer' )"
  if [[ "${timer}" != "null" ]]; then
    extra=" 持续 ${timer}秒"
  fi
  local str
  str="Pi-hole $(echo "${data}" | jq --raw-output '.blocking')${extra}"
  # Translate blocking status
  str=${str/enabled/启用}
  str=${str/disabled/禁用}

  # Logout from the API
  LogoutAPI

  echo -e "${OVER}  ${TICK} ${str}"
  exit 0
}

piholeLogging() {
  shift
  if [[ "${1}" == "-h" ]] || [[ "${1}" == "--help" ]]; then
    echo "用法：pihole logging [options]
示例：'pihole logging on'
指定是否应使用 Pi-hole 日志

选项：
  on                  在 /var/log/pihole/pihole.log 启用 Pi-hole 日志
  off                 禁用并刷新 /var/log/pihole/pihole.log 的 Pi-hole 日志
  off noflush         禁用 /var/log/pihole/pihole.log 的 Pi-hole 日志"
    exit 0
  elif [[ "${1}" == "off" ]]; then
    # Disable logging
    setFTLConfigValue dns.queryLogging false
    if [[ "${2}" != "noflush" ]]; then
      # Flush logs
      "${PI_HOLE_BIN_DIR}"/pihole -f
    fi
    echo -e "  ${INFO} 正在禁用日志..."
    local str="日志已禁用！"
  elif [[ "${1}" == "on" ]]; then
    # Enable logging
    setFTLConfigValue dns.queryLogging true
    echo -e "  ${INFO} 正在启用日志..."
    local str="日志已启用！"
  else
    echo -e "  ${COL_RED}无效选项${COL_NC}
  尝试 'pihole logging --help' 获取更多信息。"
    exit 1
  fi
  echo -e "${OVER}  ${TICK} ${str}"
}

analyze_ports() {
  local lv4 lv6 port=${1}
  # FTL is listening at least on at least one port when this
  # function is getting called
  # Check individual address family/protocol combinations
  # For a healthy Pi-hole, they should all be up (nothing printed)
  lv4="$(ss --ipv4 --listening --numeric --tcp --udp src :${port})"
  if grep -q "udp " <<< "${lv4}"; then
      echo -e "     ${TICK} UDP (IPv4)"
  else
      echo -e "     ${CROSS} UDP (IPv4)"
  fi
  if grep -q "tcp " <<< "${lv4}"; then
      echo -e "     ${TICK} TCP (IPv4)"
  else
      echo -e "     ${CROSS} TCP (IPv4)"
  fi
  lv6="$(ss --ipv6 --listening --numeric --tcp --udp src :${port})"
  if grep -q "udp " <<< "${lv6}"; then
      echo -e "     ${TICK} UDP (IPv6)"
  else
      echo -e "     ${CROSS} UDP (IPv6)"
  fi
  if grep -q "tcp " <<< "${lv6}"; then
      echo -e "     ${TICK} TCP (IPv6)"
  else
      echo -e "     ${CROSS} TCP (IPv6)"
  fi
  echo ""
}

statusFunc() {
    # Determine if there is pihole-FTL service is listening
    local pid port ftl_pid_file block_status

    ftl_pid_file="$(getFTLConfigValue files.pid)"

    pid="$(getFTLPID ${ftl_pid_file})"

    if [[ "$pid" -eq "-1" ]]; then
        case "${1}" in
            "web") echo "-1";;
            *) echo -e "  ${CROSS} DNS 服务未运行";;
        esac
        exit 0
    else
        # get the DNS port pihole-FTL is listening on
        port="$(getFTLConfigValue dns.port)"
        if [[ "${port}" == "0" ]]; then
            case "${1}" in
                "web") echo "-1";;
                *) echo -e "  ${CROSS} DNS 服务未监听";;
            esac
            exit 0
        else
            if [[ "${1}" != "web" ]]; then
                echo -e "  ${TICK} FTL 正在监听端口 ${port}"
                analyze_ports "${port}"
            fi
        fi
    fi

  # Determine if Pi-hole's blocking is enabled
  block_status=$(getFTLConfigValue dns.blocking.active)
  if [ ${block_status} == "true" ]; then
    case "${1}" in
      "web") echo "$port";;
      *) echo -e "  ${TICK} Pi-hole 屏蔽已启用";;
    esac
  else
    case "${1}" in
      "web") echo 0;;
      *) echo -e "  ${CROSS} Pi-hole 屏蔽已禁用";;
    esac
  fi

  exit 0
}

tailFunc() {
  # Warn user if Pi-hole's logging is disabled
  local logging_enabled
  logging_enabled=$(getFTLConfigValue dns.queryLogging)
  if [[ "${logging_enabled}" != "true" ]]; then
    echo "  ${CROSS} 警告：查询日志已禁用"
  fi
  echo -e "  ${INFO} 按 Ctrl-C 退出"

  # Get logfile path
  LOGFILE=$(getFTLConfigValue files.log.dnsmasq)
  readonly LOGFILE

  # Strip date from each line
  # Color blocklist/denylist/wildcard entries as red
  # Color A/AAAA/DHCP strings as white
  # Color everything else as gray
  tail -f $LOGFILE | grep --line-buffered -- "${1}" | sed -E \
    -e "s,($(date +'%b %d ')| dnsmasq\[[0-9]*\]),,g" \
    -e "s,(.*(denied |gravity blocked ).*),${COL_RED}&${COL_NC}," \
    -e "s,.*(query\\[A|DHCP).*,${COL_NC}&${COL_NC}," \
    -e "s,.*,${COL_GRAY}&${COL_NC},"
  exit 0
}

piholeCheckoutFunc() {
  if [ -n "${DOCKER_VERSION}" ]; then
    echo -e "${CROSS} 此功能在 Docker 镜像中不受支持"
    echo "请按照以下步骤构建自定义镜像："
    echo "https://github.com/pi-hole/docker-pi-hole?tab=readme-ov-file#building-the-image-locally"
    exit 0
  else
    if [[ "$2" == "-h" ]] || [[ "$2" == "--help" ]]; then
      echo "将 Pi-hole 子系统切换到不同的 GitHub 分支
    用法：${COL_GREEN}pihole checkout${COL_NC} ${COL_YELLOW}shortcut${COL_NC}
        或 ${COL_GREEN}pihole checkout${COL_NC} ${COL_PURPLE}repo${COL_NC} ${COL_CYAN}branch${COL_NC}

  示例：${COL_GREEN}pihole checkout${COL_NC} ${COL_YELLOW}master${COL_NC}
       或  ${COL_GREEN}pihole checkout${COL_NC} ${COL_PURPLE}ftl ${COL_CYAN}development${COL_NC}

  快捷方式：
    ${COL_YELLOW}master${COL_NC}            更新所有子系统到最新稳定版
    ${COL_YELLOW}dev${COL_NC}               更新所有子系统到最新开发版

  个别组件：
    ${COL_PURPLE}core${COL_NC} ${COL_CYAN}branch${COL_NC}       更改 Pi-hole 核心子系统的分支
    ${COL_PURPLE}web${COL_NC} ${COL_CYAN}branch${COL_NC}        更改 Web 界面子系统的分支
    ${COL_PURPLE}ftl${COL_NC} ${COL_CYAN}branch${COL_NC}        更改 Pi-hole FTL 子系统的分支"

      exit 0
    fi

    #shellcheck source=./advanced/Scripts/piholeCheckout.sh
    source "${PI_HOLE_SCRIPT_DIR}"/piholeCheckout.sh
    shift
    checkout "$@"
  fi
}

tricorderFunc() {
  local tricorder_token
  if [[ ! -p "/dev/stdin" ]]; then
    echo -e "  ${INFO} 请勿直接调用 Tricorder"
    exit 1
  fi

  tricorder_token=$(curl --silent --fail --show-error --upload-file "-" https://tricorder.pi-hole.net/upload < /dev/stdin 2>&1)
  if [[ "${tricorder_token}" != "https://tricorder.pi-hole.net/"* ]]; then
      echo -e "${CROSS} 上传失败，请联系 Pi-hole 支持以获取帮助。"
      # Log curl error (if available)
      if [ -n "${tricorder_token}" ]; then
          echo -e "${INFO} 错误消息：${COL_RED}${tricorder_token}${COL_NC}\\n"
          tricorder_token=""
      fi
      exit 1
  fi
  echo "上传成功，您的令牌是：${COL_GREEN}${tricorder_token}${COL_NC}"
  exit 0
}

updateCheckFunc() {
  "${PI_HOLE_SCRIPT_DIR}"/updatecheck.sh "$@"
  exit 0
}

unsupportedFunc(){
  echo "此功能在 Docker 镜像中不受支持"
  exit 0
}

helpFunc() {
  echo "用法：pihole [options]
示例：'pihole allow -h'
在特定命令后添加 '-h' 以获取更多使用信息

域名选项：
  allow, allowlist    允许域名
  deny, denylist      拒绝域名
  --regex, regex      正则拒绝域名
  --allow-regex       正则允许域名
  --wild, wildcard    通配符拒绝域名
  --allow-wild        通配符允许域名
                        添加 '-h' 获取更多关于 allow/deny 的用法

调试选项：
  -d, debug           启动调试会话
                        添加 '-c' 或 '--check-database' 以包含 Pi-hole 数据库完整性检查
                        添加 '-a' 以自动上传日志到 tricorder.pi-hole.net
  -f, flush           刷新 Pi-hole 日志
  -r, repair          修复 Pi-hole 子系统
  -t, tail [arg]      查看 Pi-hole 日志的实时输出。
                      添加可选参数以过滤日志
                      （支持正则表达式）
  api <endpoint>      查询 Pi-hole API 端点
                        在 <endpoint> 之前加上 'verbose' 选项以显示身份验证和状态消息


选项：
  setpassword [pwd]   设置 Web 界面的密码
                        如果没有可选参数，将交互式读取密码。
                        当直接指定密码时，请将其用单引号括起来。
  -g, updateGravity   更新广告服务域名列表
  -h, --help, help    显示此帮助对话框
  -l, logging         指定是否应使用 Pi-hole 日志
                        添加 '-h' 获取更多关于 logging 的用法
  -q, query           查询指定域名的广告列表
                        添加 '-h' 获取更多关于 query 的用法
  -up, updatePihole   更新 Pi-hole 子系统
                        添加 '--check-only' 以在执行更新前退出脚本。
  -v, version         显示 Pi-hole、Web 界面和 FTL 的安装版本
  uninstall           从系统中卸载 Pi-hole
  status              显示 Pi-hole 子系统的运行状态
  enable              启用 Pi-hole 子系统
                        添加 '-h' 获取更多关于 enable 的用法
  disable             禁用 Pi-hole 子系统
                        添加 '-h' 获取更多关于 disable 的用法
  reloaddns           更新列表并刷新缓存，无需重启 DNS 服务器
  reloadlists         更新列表但不刷新缓存或重启 DNS 服务器
  checkout            将 Pi-hole 子系统切换到不同的 GitHub 分支
                        添加 '-h' 获取更多关于 checkout 的用法
  networkflush        刷新存储在 Pi-hole 网络表中的信息
                        添加 '--arp' 以额外刷新 ARP 表 ";
  exit 0
}

if [[ $# = 0 ]]; then
  helpFunc
fi

# functions that do not require sudo power
need_root=
case "${1}" in
  "-h" | "help" | "--help"        ) helpFunc;;
  "-v" | "version"                ) versionFunc;;
  "-c" | "chronometer"            ) chronometerFunc "$@";;
  "-q" | "query"                  ) queryFunc "$@";;
  "status"                        ) statusFunc "$2";;
  "tricorder"                     ) tricorderFunc;;
  "allow" | "allowlist"           ) listFunc "$@";;
  "deny" | "denylist"             ) listFunc "$@";;
  "--wild" | "wildcard"           ) listFunc "$@";;
  "--regex" | "regex"             ) listFunc "$@";;
  "--allow-regex" | "allow-regex" ) listFunc "$@";;
  "--allow-wild" | "allow-wild"   ) listFunc "$@";;
  "enable"                        ) piholeEnable true "$2";;
  "disable"                       ) piholeEnable false "$2";;
  "api"                           ) shift; apiFunc "$@"; exit 0;;

  # we need to add all arguments that require sudo power to not trigger the * argument
  "-f" | "flush"                  ) need_root=true;;
  "-up" | "updatePihole"          ) need_root=true;;
  "-r"  | "repair"                ) need_root=true;;
  "-l" | "logging"                ) need_root=true;;
  "uninstall"                     ) need_root=true;;
  "-d" | "debug"                  ) need_root=true;;
  "-g" | "updateGravity"          ) need_root=true;;
  "reloaddns"                     ) need_root=true;;
  "reloadlists"                   ) need_root=true;;
  "setpassword"                   ) need_root=true;;
  "checkout"                      ) need_root=true;;
  "updatechecker"                 ) need_root=true;;
  "arpflush"                      ) need_root=true;; # Deprecated, use networkflush instead
  "networkflush"                  ) need_root=true;;
  "-t" | "tail"                   ) need_root=true;;
  *                               ) helpFunc;;
esac

# In the case of alpine running in a container, the USER variable appears to be blank
# which prevents the next trap from working correctly. Set it by running whoami
if [[ -z ${USER} ]]; then
  USER=$(whoami)
fi

# Check if the current user is not root and if the command
# requires root. If so, exit with an error message.
# Add an exception for the user "pihole" to allow the webserver running gravity
if [[ ( $EUID -ne 0 && ${USER} != "pihole" ) && -n "${need_root}" ]]; then
  echo -e "  ${CROSS} 此 Pi-hole 命令需要 root 权限，请尝试："
  echo -e "      ${COL_GREEN}sudo pihole $*${COL_NC}"
  exit 1
fi

# Handle redirecting to specific functions based on arguments
case "${1}" in
  "-d" | "debug"                  ) debugFunc "$@";;
  "-f" | "flush"                  ) flushFunc "$@";;
  "-up" | "updatePihole"          ) updatePiholeFunc "$@";;
  "-r"  | "repair"                ) repairPiholeFunc;;
  "-g" | "updateGravity"          ) updateGravityFunc "$@";;
  "-l" | "logging"                ) piholeLogging "$@";;
  "uninstall"                     ) uninstallFunc;;
  "reloaddns"                     ) reloadDNS "reload";;
  "reloadlists"                   ) reloadDNS "reload-lists";;
  "setpassword"                   ) SetWebPassword "$@";;
  "checkout"                      ) piholeCheckoutFunc "$@";;
  "updatechecker"                 ) shift; updateCheckFunc "$@";;
  "arpflush"                      ) arpFunc "$@";; # Deprecated, use networkflush instead
  "networkflush"                  ) networkFlush "$@";;
  "-t" | "tail"                   ) tailFunc "$2";;
  *                               ) helpFunc;;
esac
